# run gff compare between chess2.2_assembly and ALL
gffcompare -o chess2.2.assembly_2_ALL.combined.gffcompare_report -r chess2.2_assembly.gff ALL.combined.gtf

# get chess IDs for which a full match is observed
awk -F '\t' '$3=="="' chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap | cut -f2 | sort | uniq > chess2.2.IDs.gffcmp.complete.match.from.ALL.combined

# get all IDs currently in chess2.2
awk -F '\t|ID=|;' '$3=="transcript" {print $10}' chess2.2_assembly.gff | sort | uniq > chess2.2.IDs

# get IDs of ALL transcripts that have a full match to some transcript in chess2.2 assembly
awk -F '\t' '$3=="="' chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap | cut -f5 | awk '{gsub(/\|/,"\n")}1' | sort | uniq > ALL.combined.IDs.gffcmp.complete.match.from.chess2.2

# unite IDs of only identified complete matches for chess
comm -13 chess2.2.IDs.gffcmp.complete.match.from.ALL.combined chess2.2.IDs > chess2.2.IDs.olny.in.chess2.2

# get a list of chess IDs with class codes that do not have a complete match
grep -F -w -f chess2.2.IDs.olny.in.chess2.2 chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap | cut -f2,3 | sort | uniq > chess2.2.IDs.gffcmp.not.complete.but.contained.from.ALL.combined

!!!# get a corresponding list of ALL IDs that match some chess transcript but not with a full match
grep -F -w -f chess2.2.IDs.olny.in.chess2.2 chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap | cut -f5 |  awk '{gsub(/\|/,"\n")}1' | sort | uniq > ALL.combined.IDs.gffcmp.not.complete.but.contained.from.chess2.2

# find out which chessIDs are not found thus far (not in full match and not in contained)
comm -13 <(sort <(cat chess2.2.IDs.gffcmp.complete.match.from.ALL.combined <(cut -f1 chess2.2.IDs.gffcmp.not.complete.but.contained.from.ALL.combined))) chess2.2.IDs > chess2.2.IDs.olny.in.chess2.2.no.contained

# look at how the remaining transcripts compare
grep -F -w -f chess2.2.IDs.olny.in.chess2.2.no.contained chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap | cut -f2,3 | sort | uniq

# get a list of all IDs from ALL
awk -F '\t|\"' '$3=="transcript" {print $10}' ALL.combined.gtf | sort | uniq | > ALL.combined.IDs

# get a list of IDs from ALL that have not been matched to chess2.2_assembly thus far
comm -13 <(sort <(cat ALL.combined.IDs.gffcmp.complete.match.from.chess2.2 ALL.combined.IDs.gffcmp.not.complete.but.contained.from.chess2.2)) ALL.combined.IDs > ALL.combined.IDs.olny.in.ALL.combined.no.contained

# get a trmap which contains ALL transcripts not matched thus far
python -c 'from __future__ import print_function
import sys
lids=[]
with open("./ALL.combined.IDs.olny.in.ALL.combined.no.contained","r") as inFP:
	for line in inFP.readlines():
		lids.append(line.strip())
sids=set(lids)
print("done loading "+str(len(sids))+" IDs",file=sys.stderr)
with open("./chess2.2.assembly_2_ALL.combined.gffcompare_report.ALL.combined.gtf.tmap","r") as inFP:
	for line in inFP.readlines():
		qid=line.split("\t")[4]
		if qid in sids:
			print(line.strip())' > ALL.combined.IDs.olny.in.ALL.combined.no.contained.tmap



=======================================================================

# now we separate the set of non-matching and non-contained ALL transcripts into the groups of interest, namely:
# 1. splicing noise - transcripts within known genes (non-intronic) (c (some),k,m,n,j,e,o,y)
#     2. intronic reads - fully contained inside introns (i)
# 3. RNA-polymerase noise - intergenic expression (u,s,x,p)

# count classifications
cut -f3 ALL.combined.IDs.olny.in.ALL.combined.no.contained.tmap | sort | uniq -c
1786483 c
 756755 e.
8450552 i-
4285512 j.
  70462 k.
 271551 m.
4350811 n.
 383200 o.
 471617 p+
   4514 s+
6086886 u+
1352098 x+
  23419 y. - just don't use them

28293860 - total

# get true dataset
awk -F '\t|\"' 'FNR==NR{ids[$1]++;next} {if($10 in ids) print $0}' <(cat ALL.combined.IDs.gffcmp.complete.match.from.chess2.2) ALL.combined.gtf > ALL.combined.IDs.olny.in.ALL.combined.true.gtf

# get splicing noise - non-intronic (k,m,n,j,e,o,y) - 11928193 ALL ids
awk -v pat='k|m|n|j|e|o|y' -F '\t' '$3~pat {print $5}' ALL.combined.IDs.olny.in.ALL.combined.no.contained.tmap > ALL.combined.IDs.olny.in.ALL.combined.no.contained.non.intronic

# now get the respective gff
awk -F '\t|\"' 'FNR==NR{ids[$1]++;next} {if($10 in ids) print $0}' <(cat ALL.combined.IDs.olny.in.ALL.combined.no.contained.non.intronic) ALL.combined.gtf > ALL.combined.IDs.olny.in.ALL.combined.no.contained.non.intronic.gtf

# get splicing noise - intronic reads - 8450552 ALL ids
awk -v pat='i' -F '\t' '$3~pat {print $5}' ALL.combined.IDs.olny.in.ALL.combined.no.contained.tmap > ALL.combined.IDs.olny.in.ALL.combined.no.contained.intronic

# now get the respective gff
awk -F '\t|\"' 'FNR==NR{ids[$1]++;next} {if($10 in ids) print $0}' <(cat ALL.combined.IDs.olny.in.ALL.combined.no.contained.intronic) ALL.combined.gtf > ALL.combined.IDs.olny.in.ALL.combined.no.contained.intronic.gtf

# get RNA-polymerase noise - 7915115 ALL ids
awk -v pat='u|s|x|p' -F '\t' '$3~pat {print $5}' ALL.combined.IDs.olny.in.ALL.combined.no.contained.tmap > ALL.combined.IDs.olny.in.ALL.combined.no.contained.RNApol

# now get the respective gff
awk -F '\t|\"' 'FNR==NR{ids[$1]++;next} {if($10 in ids) print $0}' <(cat ALL.combined.IDs.olny.in.ALL.combined.no.contained.RNApol) ALL.combined.gtf > ALL.combined.IDs.olny.in.ALL.combined.no.contained.RNApol.gtf

# at the end need to make sure that there is no transcriptID overlap, meaning that each file should contain no transcript ID that exists in another file

# now that we have separate gtf files for each class of transcripts to be simulated we need to come up with means to estimate transcription
# what we can do is find "=" matches for each annotation with a tissue-specific annotation
# then we can run polyester to simulate reads based on inferred distributions from the tissue specific expression

# another question to consider is how to go about the various biases present in the data (GC/5'/3')?Q




Simultaion

1/3 is noise and 2/3 is from real genes
30 mil reads per sample
10 samples total

intergenic - normally distributed around low level
splicing noise is dependant on the parent locus expression (highly expressed genes, will have more reads coming form noise (while the fraction of ))


how many reads in each bin across all 10000 experiments

10000 lncRNA and 10000 prot-coding (can be poicked at random)
for each select some number (what number of transcripts per locus) 